% !TeX root = ../../thesis.tex

% ~10 pages 

\chapter{Results}
\label{chap:results}

In this thesis a method has been developed that uses the semantic web to improve sensor data discovery as well as the integration and aggregation of sensor data from multiple sources. Chapter \ref{chap:design} provides the outline of such a method and Chapter \ref{chap:impl} presents a proof of concept. In the following paragraphs the outcomes and results of this method are discussed. Afterwards, a comparison is made with the \acf{csw} and with semantic sensor data middle ware. 

\section{Implementation differences between Sensor Observation Services}
\label{par:differences}
The sources of sensor data used in this thesis were two \aclp{sos}. The first \ac{sos} is maintained by the \acf{rivm}. This service contains air quality sensor data for the Netherlands. The second \ac{sos} is maintained by the \ac{ircel} and contains air quality sensor data for Belgium. In the process of making an automated way for approaching these \aclp{sos} a couple of implementation differences surfaced. Even though both use the \ac{swe} standards it turned out they are not exactly the same. 

\begin{sloppypar}
	First of all, they have different approaches for making identifiers. The \ac{rivm} has \acp{uri} for acp{foi} like \texttt{NL.RIVM.AQ/SPO\_F-NL00002\_00008\_101\_101}. Offerings are named like \texttt{NL.RIVM.AQ/STA-NL00002/38} and procedures like \texttt{NL.RIVM.AQ/SPP-NL\_A\_5090150901}. Their observed properties \acp{uri} are reusing the `Eionet' vocabulary by the \ac{eea} and look like: \url{http://dd.eionet.europa.eu/vocabulary/aq/pollutant/1}. The \ac{ircel} has a different approach to these identifiers. They describe \acp{foi} with \acp{uri} such as \texttt{BELAB01}. Procedures are simply assigned a five or six digit integer like \texttt{10607}. Observed properties have recieved identifiers which are a combination of letters and integers, such as \texttt{44201 - O3}. Offerings are named as a combination of observed property and procedures: \texttt{44201 - O3\_.\_6711}. Looking at both methods for creating identifiers it is clear that there is no resemblance between the two \aclp{sos}. There is not an easy way to match the identifiers of both \aclp{sos}. This has to do with the fact that the \ac{swe} standards typically allow `any \ac{uri}' to be provided, without further specification of its structure. 
\end{sloppypar}

\begin{sloppypar}
Another difference between the two \aclp{sos} is that they supply different kinds of content in their response documents. For example, offering definitions in the capabilities document from \ac{ircel} contain bounding boxes to provide an indication of their geographical coverage. On the other hand, the capabilities document by the \ac{rivm} does not provide any data related to the physical locations at all. The \texttt{DescribeSensor} responses by the \ac{ircel} include a point geometry as part of the sensor's metadata, while the \ac{rivm} provides the \ac{foi} identifier for which the geometry can be retrieved using a a \texttt{GetFeatureOfInterest} request. This \texttt{GetFeatureOfInterest} request by \ac{ircel} returns the geometries of \acp{foi} with \acp{crs} in the \texttt{urn:ogc:def:nil:OGC:unknown} format. The \ac{sos} by the \ac{rivm} returns geometries of \acp{foi} with \acp{crs} in the \texttt{http://www.opengis.net/def/nil/OGC/0/unknown} format. 
\end{sloppypar}

\begin{sloppypar}
Another implementation difference is visible in the \texttt{GetObservation} response documents. When retrieving sensor data from the \ac{sos} using \texttt{GetObservation} requests \ac{ircel} provides this data as an array of comma separated values, using the \ac{swe} Array Observation class. With this method all metadata that is shared by observations from the same sensor (observed property, procedure, \ac{foi}, \ac{uom}) are only defined once in the response document. The \ac{rivm} on the other hand provides the observation data embedded in \ac{xml} tags using the \ac{om} Measurement class. With this approach all observations are self describing, defining the metadata of a sensor for each observation it makes.   
\end{sloppypar}

All these minor differences have caused the implementation of the method described in Chapter \ref{chap:design} to be more complex than initially expected. Especially providing a describe sensor document with as much information as possible (containing related features of interest, observed property and offerings) is very important for making sense of the metadata. It is much better to work with the response document if it uses the appropriate \ac{sensorml} classes to describe sensor metadata, instead of adding it to the more general `swe:keywords', or abstract section for example. Especially with optional metadata it is not wrong to include it in one of these sections, but this way it is not machine understandable. 

\section{Semantics in Sensor Observation Services}
The metadata in \aclp{sos} do not necessarily contain semantic \acp{uri} as identifiers. Therefore the method of Chapter \ref{chap:design} includes a process for creating these semantic \acp{uri} based on the \ac{swe} \ac{xml} schema's and corresponding classes in linked data ontologies. However, two issues presented themselves during this process: some identifiers used in a \ac{sos} are completely meaningless, especially from a machine readable point of view. The lack of a defined observable property is the main issue here. The second issue is the complexity of automatically creating \acp{uri} for metadata, where each \ac{uri} is unique, compact and valid.  

\subsection{Mapping of observable properties}
In Paragraph \ref{par:differences} the differences between identifiers in the \aclp{sos} by \ac{ircel} and the \ac{rivm} have been described. They are compliant with the \ac{swe} standards, which require any \ac{uri} regardless of semantics. In the method of Chapter \ref{chap:design} the sensor location, temporal range and observed property are modelled as the main elements of the logical query input. Therefore, ill-defined observed properties are problematic when automatically retrieving (meta)data from different services. Both \aclp{sos} used in this thesis had non-machine understandable identifiers for observed properties. The vocabulary used by the \ac{rivm} is a step in the right direction, but the identifiers do not resolve to an \ac{rdf} document, but to the \ac{eea} website. This is mainly a human understandable solution. The \ac{sos} by \ac{ircel} contains identifiers which are a string of seemingly random characters, ending with an abbreviation of the observable property involved. This is partly human understandable.   

Identifying which observable properties in one \ac{sos} are the same as observable properties found in another \ac{sos} was not automatically possible in this case. It could be achieved with a minimum of semantics, such as an \ac{rdf} document containing just a triple with the `owl:sameAs' predicate to a linked data ontology or the `foaf:name' predicate to store at least the name of the observable property. By assigning just a single triple like one of these to a \ac{uri} it also already possible for an automatic process to find out which \acp{uri} represent the same observable property. 

 A manual mapping had to be implemented, because the method was currently not able to automatically create linked data from the metadata of any \ac{sos} using just the \ac{http} address as input. This manual mapping is a small \ac{rdf} document containing one triple for every observable property \ac{uri}, using the `owl:sameAs' predicate to link it to the corresponding DBPedia definition. The proof of concept implementation takes both the \ac{http} address of the \ac{sos} and this manual mapping as input.          

\subsection{Automatically creating URIs}
The method presented by this thesis includes a process to automatically assign \acp{uri} to non-semantic data and to define \acp{uri} for concepts that are implicitly stored in a \ac{sos}. For example, a \ac{sos} could contain one procedure and ten \acp{foi}. The actually deployed sensors are implicitly represented by combining the procedure with a \ac{foi}, although they are not part of the \ac{sos} \ac{xml} schema's. If an \ac{uri} is automatically created for data from an unknown source there is an amount of uncertainty about what the resulting \acp{uri} will look like. Either a random identifier can be used, or the identifier that is already provided by the data source. This identifier will most likely contain some reference to the nature of the real world thing the \ac{uri} represents. Therefore this could be preferred to a completely random identifier. However, as shown in Paragraph \ref{par:differences} identifiers can also be random or non-semantic \acp{url}. Since the \ac{om} schema allows simply `any \ac{uri}', very long and strange \acp{uri} can be created when adding the given identifier to the \ac{uri}. 

Therefore, the proof of concept implementation used a combination of random and existing identifiers. It uses the name of the \ac{sos} organisation (`RIVM', `Ircel-Celine'), the type of metadata (`procedure', `FOI') and a random integer ranging from zero to the amount of instances of this type. However, this is not a watertight solution either, because the name of the organisation could create an invalid \ac{url}. In the proof of concept invalid characters and spaces had to be escaped to prevent this. The name of the organisation was selected over the title of the \ac{sos}, since those are often very verbose. However, using the name of the organisation the problem could arise that multiple \aclp{sos} are maintained by the same organisation. This could lead to non-unique identifiers. The need for more research into methods for automatically creating robust \acp{url} for data from different sources is further described in Chapter \ref{chap:futureResearch}.      

\section{Spatial queries with SPARQL}
\label{par:spQueries}
Spatial queries are an essential part of the method presented in this thesis. They are used in the process of selecting which sensors are relevant to a user's data request. However, the proof of concept implementation showed that the performance of vector geometries in \ac{sparql} is not very good. Also, the order of latitude and longitude in point coordinates turned out to be a problem. In the next two paragraphs these issues will be discuss, together with the implemented solutions.     

\subsection{Vector queries with SPARQL}
The method described in Paragraph \ref{par:logicalDesign} starts with discovering metadata of sensors that are inside a spatial feature. This feature can be a raster cell or vector geometry. Spatial \ac{sparql} queries with raster cells are relatively fast. However, with vector geometries the performance is less good. Therefore, three methods for spatial querying have been implemented for retrieving metadata of sensors inside a vector feature. First of all, \ac{sparql} queries in which the complete geometry of a vector feature is added to a spatial filter expression. Second of all, \ac{sparql} queries in which \ac{eea} raster cells overlapping the vector geometry are added to a spatial filter expression. Third of all, an approach in which the spatial querying is performed on the \ac{sos} side using spatial filters in \texttt{GetObservation} requests. Considering all advantages and disadvantages of the three methods the proof of concept implementation selects the second method by default. The other methods can be selected using an optional input parameter. The three methods are described in more detail below.

With the first method the \ac{wps} does not have to perform any further spatial queries. A single query retrieves the metadata of sensors inside the geometry. However, this query is time consuming, especially when more complicated vector geometries are used. Furthermore, when they become more complicated their \ac{wkt} definition also get more verbose. This can lead to a rejection of the query by the endpoint, as it exceeds a maximum amount of characters defined by the server. The method has been tested with Strabon and Parliament endpoints, since they both handle spatial \ac{sparql} queries. The Strabon endpoint has been used in the final proof of concept, because it handled long queries better.   

The second method performs a rough spatial filtering using raster cells in a \ac{sparql} filter. The returned sensor metadata is then filtered by the \ac{wps} using the Shapely Python package. This method performs better, but introduces an extra step in the process of retrieving metadata that shouldn't be necessary on paper. The Strabon endpoint is connected to Postgres database and has access to the PostGIS functionality of this database. Therefore, the \ac{sparql} query should perform just as well as Shapely. However, it could be that the posting of a large query also lowers the performance, as more data should be transferred to and interpreted by the Strabon endpoint. 

The third method retrieves addresses of \aclp{sos} that have metadata in a certain area from the endpoint. To these returned addresses a \texttt{GetObservation} request is send with a spatial filter. The problem that was encountered with this method is the difference in filtering capabilities between \aclp{sos}. Not all services had spatial filters implemented. If these filters would have been implemented by all of them it could have been a viable alternative. However, another disadvantage of this method is that since the detailed spatial filtering happens on the \ac{sos} side only a very rough spatial filtering is applied on the endpoint side using a bounding box. This could lead to useless requests to \aclp{sos} that have sensors inside the bounding box of the vector geometry, but not inside the vector geometry itself. 

\subsection{latitude and longitude order in point coordinates}
During the process of creating the proof of concept implementation a problem has come up regarding the order in which latitude and longitude are being presented. The \ac{sos} of the \ac{rivm} provides point geometries in WGS84 as longitude, latitude and height. However, the Strabon endpoint expects the order to be latitude, longitude and height. Mixing up the order of a point coordinate results in wrong outcomes of spatial queries. The biggest issue with the coordinate order is that there is no description of it in the \ac{crs}. The WGS84 coordinates by \ac{ircel} do not cause this problem, while the WGS84 coordinates by the \ac{rivm} do. The order of longitude and latitude should be decided upon by the geomatics and geospatial community or explicitly defined to prevent confusion. 

However, to make the current proof of concept work an ad hoc solution has been implemented based on \cite{GEO:GDAL}: coordinates defining their \ac{crs} in the format of \texttt{urn:ogc:def:crs:EPSG:unknown} are generally using the longitude, latitude order. Coordinates defining their \ac{crs} in the format of \texttt{http://www.opengis.net/def/nil/OGC/0/unknown} are generally using the latitude, longitude order. Therefore, the order is swapped for geometries with the former \ac{crs} format. The coordinates that use the latter format for their \ac{crs} are left as they are. This approach works for the \aclp{sos} used in this thesis, but is not the preferred solution.   

\section{Output data}
Data is outputted in \ac{xml} or \ac{json} according to the \ac{om} schema. However, this schema cannot be used when different processes have been used by the data that has been aggregated.

\section{Comparing the Sensor Instance Registry with a semantic knowledge base}
Comparing \cite{SW:OGC3} and \cite{SW:OGC4} with the outcomes of Chapter \ref{chap:impl}

\section{Comparing the semantic sensor middleware with a semantic knowledge base}
Comparing the outcomes of Chapter \ref{chap:impl} with methods for retrieving \ac{rdf} from a \ac{sos}

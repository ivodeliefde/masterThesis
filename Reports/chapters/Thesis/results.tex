% !TeX root = ../../thesis.tex

% ~10 pages 

\chapter{Results}
\label{chap:results}

In this thesis a method has been developed that uses the semantic web to improve sensor data discovery as well as the integration and aggregation of sensor data from multiple sources. Chapter \ref{chap:design} provides the outline of such a method and Chapter \ref{chap:impl} presents a proof of concept. In the following paragraphs the outcomes and results of this method are discussed. Afterwards, a comparison is made with the \acf{csw} and with semantic sensor data middle ware. 

\section{Implementation differences between Sensor Observation Services}
The sources of sensor data used in this thesis were two \aclp{sos}. The first \ac{sos} is maintained by the \acf{rivm}. This service contains air quality sensor data for the Netherlands. The second \ac{sos} is maintained by the \ac{ircel} and contains air quality sensor data for Belgium. In the process of making an automated way for approaching these \aclp{sos} a couple of implementation differences surfaced. Even though both use the \ac{swe} standards it turned out they are not exactly the same. 

\begin{sloppypar}
	First of all, they have different approaches for making identifiers. The \ac{rivm} has \acp{uri} for acp{foi} like \texttt{NL.RIVM.AQ/SPO\_F-NL00002\_00008\_101\_101}. Offerings are named like \texttt{NL.RIVM.AQ/STA-NL00002/38} and procedures like \texttt{NL.RIVM.AQ/SPP-NL\_A\_5090150901}. Their observed properties \acp{uri} are reusing the `Eionet' vocabulary by the \ac{eea} and look like: \url{http://dd.eionet.europa.eu/vocabulary/aq/pollutant/1}. The \ac{ircel} has a different approach to these identifiers. They describe \acp{foi} with \acp{uri} such as \texttt{BELAB01}. Procedures are simply assigned a five or six digit integer like \texttt{10607}. Observed properties have recieved identifiers which are a combination of letters and integers, such as \texttt{44201 - O3}. Offerings are named as a combination of observed property and procedures: \texttt{44201 - O3\_.\_6711}. Looking at both methods for creating identifiers it is clear that there is no resemblance between the two \aclp{sos}. There is not an easy way to match the identifiers of both \aclp{sos}. This has to do with the fact that the \ac{swe} standards typically allow `any \ac{uri}' to be provided, without further specification of its structure. 
\end{sloppypar}

\begin{sloppypar}
Another difference between the two \aclp{sos} is that they supply different kinds of content in their response documents. For example, offering definitions in the capabilities document from \ac{ircel} contain bounding boxes to provide an indication of their geographical coverage. On the other hand, the capabilities document by the \ac{rivm} does not provide any data related to the physical locations at all. The \texttt{DescribeSensor} responses by the \ac{ircel} include a point geometry as part of the sensor's metadata, while the \ac{rivm} provides the \ac{foi} identifier for which the geometry can be retrieved using a a \texttt{GetFeatureOfInterest} request. This \texttt{GetFeatureOfInterest} request by \ac{ircel} returns the geometries of \acp{foi} with \acp{crs} in the `urn:ogc:def:nil:OGC:unknown' format. The \ac{sos} by the \ac{rivm} returns geometries of \acp{foi} with \acp{crs} in the `http://www.opengis.net/def/nil/OGC/0/unknown' format. 
\end{sloppypar}

\begin{sloppypar}
Another implementation difference is visible in the \texttt{GetObservation} response documents. When retrieving sensor data from the \ac{sos} using \texttt{GetObservation} requests \ac{ircel} provides this data as an array of comma separated values, using the \ac{swe} Array Observation class. With this method all metadata that is shared by observations from the same sensor (observed property, procedure, \ac{foi}, \ac{uom}) are only defined once in the response document. The \ac{rivm} on the other hand provides the observation data embedded in \ac{xml} tags using the \ac{om} Measurement class. With this approach all observations are self describing, defining the metadata of a sensor for each observation it makes.   
\end{sloppypar}

All these minor differences have caused the implementation of the method described in Chapter \ref{chap:design} to be more complex than initially expected. Especially providing a describe sensor document with as much information as possible (containing related features of interest, observed property and offerings) is very important for making sense of the metadata. It is much better to work with the response document if it uses the appropriate \ac{sensorml} classes to describe sensor metadata, instead of adding it to the more general `swe:keywords', or abstract section for example. Especially with optional metadata it is not wrong to include it in one of these sections, but this way it is not machine understandable. 

\section{Semantics in Sensor Observation Services}
The metadata in \aclp{sos} do not necessarily contain semantic \acp{uri} as identifiers. Therefore the method of Chapter \ref{chap:design} includes a process for creating these semantic \acp{uri} based on the response documents' \ac{xml} tags and corresponding classes in linked data ontologies. However, two issues presented themselves during this process: some identifiers used in a \ac{sos} are completely meaningless, especially from a machine readable point of view. The lack of a defined observable property is the main issue here. The second issue is the complexity of automatically creating an \ac{uri} for metadata, where each \ac{uri} is unique, compact and valid.  

\subsection{Mapping of observable properties}
This is an issue when automatically retrieving metadata from different services. In the implementation this has caused a problem with identifying which observable properties in a \ac{sos} are the same as observable properties found in another \ac{sos}.

\subsection{Automatically creating an URI scheme}
If an \ac{uri} is automatically created for data from an unknown source there is an amount of uncertainty to what the \ac{uri} will look like. Either a random identifier can be assigned to it, or the identifier that is already provided by the data source. This identifier most likely contains some reference to the nature of the real world thing the \ac{uri} represents and is therefore preferable to a a completely random identifier. Adding the given identifier to the \ac{uri} can create very long and strange \acp{uri} because different data sources have a different way of creating \acp{uri} since the \ac{om} schema allows simply `any \ac{uri}'.   

\section{Spatial queries with SPARQL}
\label{par:spQueries}
For retrieving data about a vector feature three methods for spatial querying have been implemented. First of all, spatial queries in which the server side receives the complete geometry of a feature and checks which point geometries it contains. Second of all, spatial queries in which the server side receives the bounding box of the complete geometry and check which points are within it. Third of all, spatial queries in which the server side receives the \ac{eea} reference grid cell that overlap the geometry and checks which points each cell contains. With the first method the client does not have to perform any spatial queries anymore. The second and third method will also return points that are not inside the geometry of the vector feature. These points could be filtered out by the client. 

The Strabon and Parliament endpoint have been tested since they both handle GeoSPARQL queries. Strabon has been used in the final design, because the Parliament endpoint rejected certain longer queries (see \ref{par:spQueries}).

Pubby software in combination with Apache Tomcat allows for a user interface that is easier to navigate through for humans. The links stored in \ac{rdf} triples are represented as hyperlinks which can be used to navigate between pages about different concepts. 

\subsection{Vector queries}
GeoSPARQL allows spatial queries in which a geometry can be inserted in the query. The implementation uses this functionality to test for spatial relations between geometries. For example between the point geometry of a sensor and the polygon geometry of an administrative unit. However, when geometries become more complicated their \ac{wkt} definition becomes more verbose. This leads to the query being rejected based on its number of characters by the endpoint. This indicates that vector queries with complex geometries are not very efficient to include in a \ac{sparql} query.     

\subsection{Raster queries}
All raster cells are retrieved that overlap with the vector geometry. For these raster cell sensors are retrieved and later the excess ones are filtered out. 

\subsection{Bounding box queries}
Creating a bounding box around a vector feature and make \texttt{GetObservation} to the \ac{sos}.  

\subsection{Latitude and longitude order}
During the implementation a problem has come up regarding the order in which latitude and longitude are being presented in the \ac{sos}. The \ac{sos} of the \ac{rivm} provides point geometries in WGS84 as longitude, latitude and height. However, the Strabon endpoint expects the order to be latitude, longitude and height. This results false outcomes of spatial queries.    

\section{Output data}
Data is outputted in \ac{xml} or \ac{json} according to the \ac{om} schema. However, this schema cannot be used when different processes have been used by the data that has been aggregated.

\section{Comparing the Sensor Instance Registry with a semantic knowledge base}
Comparing \cite{SW:OGC3} and \cite{SW:OGC4} with the outcomes of Chapter \ref{chap:impl}

\section{Comparing the semantic sensor middleware with a semantic knowledge base}
Comparing the outcomes of Chapter \ref{chap:impl} with methods for retrieving \ac{rdf} from a \ac{sos}
